# Orderflow Service

A Bun-based HTTP service for handling order operations in the Aztec OTC Desk.

## Endpoints

### POST /order
Create a new order. The `orderId` is automatically generated by the server.

**Important**: Each `escrowAddress` can only be used once. Attempting to create an order with an existing escrow address will return a 409 Conflict error.

**Request Body:**
```json
{
  "escrowAddress": "0x1234...",
  "sellTokenAddress": "0x5678...",
  "sellTokenAmount": "1000000000000000000",
  "buyTokenAddress": "0x9abc...",
  "buyTokenAmount": "2000000000000000000"
}
```

**Note**: BigInt values (`sellTokenAmount`, `buyTokenAmount`) should be sent as strings in JSON and will be returned as strings in responses.

**Request:**
```bash
curl -X POST http://localhost:3000/order \
  -H "Content-Type: application/json" \
  -d '{
    "escrowAddress": "0x1234567890abcdef1234567890abcdef12345678",
    "sellTokenAddress": "0x5678901234abcdef5678901234abcdef56789012",
    "sellTokenAmount": "1000000000000000000",
    "buyTokenAddress": "0x9abcdef123456789abcdef123456789abcdef12",
    "buyTokenAmount": "2000000000000000000"
  }'
```

**Response:**
```json
{
  "success": true,
  "message": "Order created successfully",
  "data": {
    "orderId": "generated-uuid-here",
    "escrowAddress": "0x1234567890abcdef1234567890abcdef12345678",
    "sellTokenAddress": "0x5678901234abcdef5678901234abcdef56789012",
    "sellTokenAmount": "1000000000000000000",
    "buyTokenAddress": "0x9abcdef123456789abcdef123456789abcdef12",
    "buyTokenAmount": "2000000000000000000"
  }
}
```

**Error Response (409 Conflict):**
```json
{
  "success": false,
  "error": "Order with escrow address 0x1234567890abcdef1234567890abcdef12345678 already exists"
}
```

### GET /order
Retrieve order(s). Always returns an array for consistent interface. Supports filtering by various parameters.

**Query Parameters:**
- `id` - Get specific order by order ID
- `escrow_address` - Filter by escrow address
- `sell_token_address` - Filter by sell token address  
- `buy_token_address` - Filter by buy token address

Parameters can be combined for more specific filtering.

**Get All Orders:**
```bash
curl http://localhost:3000/order
```

**Response (All Orders):**
```json
{
  "success": true,
  "message": "Retrieved 2 order(s)",
  "data": [
    {
      "orderId": "uuid-1",
      "escrowAddress": "0x1234567890abcdef1234567890abcdef12345678",
      "sellTokenAddress": "0x5678901234abcdef5678901234abcdef56789012",
      "sellTokenAmount": "1000000000000000000",
      "buyTokenAddress": "0x9abcdef123456789abcdef123456789abcdef12",
      "buyTokenAmount": "2000000000000000000"
    },
    {
      "orderId": "uuid-2",
      "escrowAddress": "0xabcdef1234567890abcdef1234567890abcdef12",
      "sellTokenAddress": "0xfedcba0987654321fedcba0987654321fedcba09",
      "sellTokenAmount": "5000000000000000000",
      "buyTokenAddress": "0x1111222233334444555566667777888899990000",
      "buyTokenAmount": "3000000000000000000"
    }
  ]
}
```

**Get Specific Order:**
```bash
curl http://localhost:3000/order?id=uuid-1
```

**Response (Single Order in Array):**
```json
{
  "success": true,
  "message": "Order retrieved successfully",
  "data": [
    {
      "orderId": "uuid-1",
      "escrowAddress": "0x1234567890abcdef1234567890abcdef12345678",
      "sellTokenAddress": "0x5678901234abcdef5678901234abcdef56789012",
      "sellTokenAmount": "1000000000000000000",
      "buyTokenAddress": "0x9abcdef123456789abcdef123456789abcdef12",
      "buyTokenAmount": "2000000000000000000"
    }
  ]
}
```

**Filter by Escrow Address:**
```bash
curl "http://localhost:3000/order?escrow_address=0x1234567890abcdef1234567890abcdef12345678"
```

**Filter by Sell Token:**
```bash
curl "http://localhost:3000/order?sell_token_address=0x5678901234abcdef5678901234abcdef56789012"
```

**Filter by Buy Token:**
```bash
curl "http://localhost:3000/order?buy_token_address=0x9abcdef123456789abcdef123456789abcdef12"
```

**Combined Filters:**
```bash
curl "http://localhost:3000/order?sell_token_address=0x5678901234abcdef5678901234abcdef56789012&buy_token_address=0x9abcdef123456789abcdef123456789abcdef12"
```

**Filtered Response Example:**
```json
{
  "success": true,
  "message": "Retrieved 1 order(s) filtered by sell token: 0x5678901234abcdef5678901234abcdef56789012",
  "data": [
    {
      "orderId": "uuid-1",
      "escrowAddress": "0x1234567890abcdef1234567890abcdef12345678",
      "sellTokenAddress": "0x5678901234abcdef5678901234abcdef56789012",
      "sellTokenAmount": "1000000000000000000",
      "buyTokenAddress": "0x9abcdef123456789abcdef123456789abcdef12",
      "buyTokenAmount": "2000000000000000000"
    }
  ]
}
```

**Error Response (Order Not Found):**
```json
{
  "success": false,
  "error": "Order with ID uuid-nonexistent not found",
  "data": []
}
```

## Development

### Install Dependencies
```bash
bun install
```

### Run in Development Mode
```bash
bun run dev
```

### Run in Production Mode
```bash
bun run start
```

### Build
```bash
bun run build
```

### Testing
```bash
# Run all tests
bun test

# Run specific test suites
bun run test:db           # Database tests only
bun run test:handlers     # Handler tests only
bun run test:integration  # Integration tests only

# Watch mode for development
bun run test:watch
```

**Test Coverage:**
- ✅ **Database Tests**: Order creation, deduplication, retrieval, and filtering
- ✅ **Handler Tests**: POST/GET endpoints with various scenarios
- ✅ **Integration Tests**: Comprehensive filtering and edge cases
- ✅ **Error Handling**: Invalid inputs, duplicate constraints, server errors

## Database

The service uses a **pluggable database architecture** with a clean interface that supports multiple database backends.

### Current Implementation
- **Default**: SQLite using Bun's built-in SQLite support
- **Database file**: `orders.sqlite` (created automatically in project root)

### Database Architecture
The service uses **dependency injection** with an interface-based approach (`IDatabase`) for clean separation of concerns:

```typescript
// Database is created and injected in main function
const database = new SQLiteDatabase();
database.initialize();

// Handlers receive database through dependency injection
const { handleCreateOrder, handleGetOrder } = createOrderHandlers(database);

// Easy to swap for different implementations
const database = new PostgreSQLDatabase("connection-string");
const handlers = createOrderHandlers(database);
```

**Benefits:**
- ✅ No global state or singletons
- ✅ Easy testing with mock databases
- ✅ Clean dependency management
- ✅ Explicit database lifecycle control

### Database Schema
```sql
CREATE TABLE orders (
  orderId TEXT PRIMARY KEY,
  escrowAddress TEXT NOT NULL UNIQUE,
  sellTokenAddress TEXT NOT NULL,
  sellTokenAmount TEXT NOT NULL,
  buyTokenAddress TEXT NOT NULL,
  buyTokenAmount TEXT NOT NULL,
  createdAt DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

## Implementation Status

✅ **POST /order** - Fully implemented with SQLite persistence and unique escrow address constraint  
✅ **GET /order** - Fully implemented with support for retrieving all orders or specific order by ID

## TODO

- [x] Implement order creation logic in `handleCreateOrder`
- [x] Add database integration with SQLite
- [x] Add UUID generation for order IDs
- [x] Implement pluggable database architecture with interfaces
- [x] Add unique constraint for escrow addresses
- [x] Implement order retrieval logic in `handleGetOrder`
- [x] Add dependency injection for database
- [x] Add query filtering by escrow, sell token, and buy token addresses
- [x] Add comprehensive test suite with database, handler, and integration tests
- [ ] Add input validation and sanitization
- [ ] Add authentication and authorization
- [ ] Add error handling and logging
- [ ] Implement alternative database providers (PostgreSQL, MongoDB, etc.)
